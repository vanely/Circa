import { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { AuthService } from '../services/auth';

// Zod schemas for request validation
const magicLinkRequestSchema = z.object({
  email: z.string().email(),
});

const magicLinkVerifySchema = z.object({
  token: z.string(),
});

export const authRoutes: FastifyPluginAsync = async (fastify) => {
  // Create auth service
  const authService = new AuthService(fastify.prisma);
  
  // Setup a cleanup interval for expired tokens
  const cleanupInterval = setInterval(() => {
    authService.cleanupExpiredTokens();
  }, 15 * 60 * 1000); // Run every 15 minutes
  
  // Clean up interval on server close
  fastify.addHook('onClose', () => {
    clearInterval(cleanupInterval);
  });

  // Request a magic link
  fastify.post('/login', {
    schema: {
      body: {
        type: 'object',
        required: ['email'],
        properties: {
          email: { type: 'string', format: 'email' },
        },
      },
    },
  }, async (request, reply) => {
    try {
      const { email } = magicLinkRequestSchema.parse(request.body);
      
      // Get the origin from request headers or use a default
      const origin = request.headers.origin || 'http://localhost:5173';
      
      // Send magic link
      await authService.sendMagicLink(email, origin);
      
      return reply.status(200).send({ 
        message: 'Magic link sent successfully',
        email: email
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return reply.status(400).send({ message: 'Invalid email format' });
      }
      
      fastify.log.error(error);
      return reply.status(500).send({ message: 'Failed to send magic link' });
    }
  });

  // Verify a magic link token
  fastify.post('/verify', {
    schema: {
      body: {
        type: 'object',
        required: ['token'],
        properties: {
          token: { type: 'string' },
        },
      },
    },
  }, async (request, reply) => {
    try {
      const { token } = magicLinkVerifySchema.parse(request.body);
      
      // Verify token and get user
      const user = await authService.verifyMagicLink(token);
      
      if (!user) {
        return reply.status(400).send({ message: 'Invalid or expired token' });
      }
      
      // Generate JWT
      const jwt = authService.generateToken(request, user);
      
      return reply.status(200).send({
        message: 'Authentication successful',
        token: jwt,
        user: {
          id: user.id,
          email: user.email,
          displayName: user.displayName,
          avatarMediaId: user.avatarMediaId,
        },
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return reply.status(400).send({ message: 'Invalid token format' });
      }
      
      fastify.log.error(error);
      return reply.status(500).send({ message: 'Authentication failed' });
    }
  });

  // Get current user
  fastify.get('/me', {
    onRequest: [fastify.authenticate],
  }, async (request, reply) => {
    // User is already authenticated by the hook
    const userId = (request.user as { id: string }).id;
    
    try {
      const user = await fastify.prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          email: true,
          displayName: true,
          bio: true,
          avatarMediaId: true,
          createdAt: true,
          organizer: {
            select: {
              id: true,
              brandName: true,
              verificationStatus: true,
            },
          },
        },
      });
      
      if (!user) {
        return reply.status(404).send({ message: 'User not found' });
      }
      
      return user;
    } catch (error) {
      fastify.log.error(error);
      return reply.status(500).send({ message: 'Failed to retrieve user data' });
    }
  });

  // Logout (client-side only, but we'll add an endpoint for symmetry)
  fastify.post('/logout', {
    onRequest: [fastify.authenticate],
  }, async (request, reply) => {
    // JWT tokens can't be invalidated, but we'll return a success message
    return reply.status(200).send({ message: 'Logged out successfully' });
  });
};
