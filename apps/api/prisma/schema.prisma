generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto, postgis]
}

// Users & Auth
model User {
  id            String    @id @default(uuid()) @db.Uuid
  email         String    @unique
  password      String?
  displayName   String
  bio           String?
  avatarMediaId String?   @db.Uuid
  avatarMedia   Media?    @relation("UserAvatar", fields: [avatarMediaId], references: [id])
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?

  // Relations
  organizer        OrganizerProfile?
  tickets          Ticket[]
  messages         Message[]
  followedEvents   EventFollow[]
  userCollectibles UserCollectible[]
  checkins         Checkin[]

  @@map("users")
}

model OrganizerProfile {
  id                 String    @id @default(uuid()) @db.Uuid
  userId             String    @unique @db.Uuid
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  brandName          String?
  verificationStatus String    @default("unverified") // unverified, pending, verified
  stripeAccountId    String?
  createdAt          DateTime  @default(now())
  events             Event[]

  @@map("organizer_profiles")
}

// Media
model Media {
  id          String    @id @default(uuid()) @db.Uuid
  r2Key       String    // Cloudflare R2 storage key
  mimeType    String
  width       Int?
  height      Int?
  blurhash    String?
  moderation  String?
  createdById String?   @db.Uuid
  createdAt   DateTime  @default(now())

  // Relations
  createdBy     User?          @relation(fields: [createdById], references: [id], onDelete: SetNull)
  userAvatars   User[]         @relation("UserAvatar")
  eventCovers   Event[]        @relation("EventCover")
  collectibles  Collectible[]
  messageAttachments MessageAttachment[]

  @@map("media")
}

// Venues
model Venue {
  id         String  @id @default(uuid()) @db.Uuid
  label      String?
  address    String?
  location   Json?   // PostGIS GEOGRAPHY(POINT) stored as JSON {lng, lat}
  visibility String  @default("public") // public, fuzzy, private_until_rsvp
  events     Event[]

  @@map("venues")
}

// Events
model Event {
  id            String   @id @default(uuid()) @db.Uuid
  organizerId   String   @db.Uuid
  organizer     OrganizerProfile @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  title         String
  summary       String?
  description   String?
  coverMediaId  String?  @db.Uuid
  coverMedia    Media?   @relation("EventCover", fields: [coverMediaId], references: [id])
  startAt       DateTime
  endAt         DateTime
  timezone      String
  venueId       String?  @db.Uuid
  venue         Venue?   @relation(fields: [venueId], references: [id])
  categories    String[]
  tags          String[]
  capacity      Int?
  visibility    String   @default("public") // public, unlisted, invite_only, approval_only
  modules       Json     @default("{}")
  theme         Json     @default("{}")
  priceMinCents Int?
  priceMaxCents Int?
  searchTsv     Unsupported("tsvector")?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  ticketTypes    TicketType[]
  tickets        Ticket[]
  waitlists      Waitlist[]
  messages       Message[]
  checkins       Checkin[]
  collectibles   Collectible[]
  eventFollows   EventFollow[]
  announcements  Announcement[]
  polls          Poll[]

  @@map("events")
}

// Ticket Types & Tickets
model TicketType {
  id         String    @id @default(uuid()) @db.Uuid
  eventId    String    @db.Uuid
  event      Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  name       String
  kind       String    // free, paid, donation, approval
  priceCents Int?
  capacity   Int?
  section    String?
  salesStart DateTime?
  salesEnd   DateTime?
  tickets    Ticket[]

  @@map("ticket_types")
}

model Ticket {
  id           String   @id @default(uuid()) @db.Uuid
  eventId      String   @db.Uuid
  event        Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId       String   @db.Uuid
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ticketTypeId String?  @db.Uuid
  ticketType   TicketType? @relation(fields: [ticketTypeId], references: [id])
  status       String   // going, maybe, waitlist, not_going, cancelled
  plusOnes     Int      @default(0)
  walletApplePassId String?
  walletGooglePassId String?
  createdAt    DateTime @default(now())

  @@unique([eventId, userId])
  @@map("tickets")
}

model Waitlist {
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  priority  Int      @default(0)
  joinedAt  DateTime @default(now())

  @@id([eventId, userId])
  @@map("waitlists")
}

// Chat & Messages
model Message {
  id         String   @id @default(uuid()) @db.Uuid
  eventId    String   @db.Uuid
  event      Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  channel    String   @default("general")
  userId     String?  @db.Uuid
  user       User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  body       String?
  createdAt  DateTime @default(now())
  reported   Boolean  @default(false)
  
  // Relations
  attachments MessageAttachment[]

  @@map("messages")
}

model MessageAttachment {
  id        String   @id @default(uuid()) @db.Uuid
  messageId String   @db.Uuid
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  mediaId   String   @db.Uuid
  media     Media    @relation(fields: [mediaId], references: [id])

  @@map("message_attachments")
}

// Check-ins
model Checkin {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  at        DateTime @default(now())
  method    String   @default("qr") // qr, manual, import

  @@map("checkins")
}

// Collectibles
model Collectible {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  type      String   // avatar, banner, badge
  mediaId   String   @db.Uuid
  media     Media    @relation(fields: [mediaId], references: [id])
  rarity    String?
  createdAt DateTime @default(now())
  
  // Relations
  userCollectibles UserCollectible[]

  @@map("collectibles")
}

model UserCollectible {
  userId        String      @db.Uuid
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  collectibleId String      @db.Uuid
  collectible   Collectible @relation(fields: [collectibleId], references: [id], onDelete: Cascade)
  acquiredAt    DateTime    @default(now())

  @@id([userId, collectibleId])
  @@map("user_collectibles")
}

// Event Follow/Save
model EventFollow {
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([userId, eventId])
  @@map("event_follows")
}

// Announcements
model Announcement {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @db.Uuid
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  title     String
  body      String
  link      String?
  pinned    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("announcements")
}

// Polls
model Poll {
  id        String      @id @default(uuid()) @db.Uuid
  eventId   String      @db.Uuid
  event     Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  question  String
  multi     Boolean     @default(false)
  createdAt DateTime    @default(now())
  options   PollOption[]

  @@map("polls")
}

model PollOption {
  id      String    @id @default(uuid()) @db.Uuid
  pollId  String    @db.Uuid
  poll    Poll      @relation(fields: [pollId], references: [id], onDelete: Cascade)
  label   String
  votes   PollVote[]

  @@map("poll_options")
}

model PollVote {
  pollId    String     @db.Uuid
  optionId  String     @db.Uuid
  option    PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  userId    String     @db.Uuid

  @@id([pollId, optionId, userId])
  @@map("poll_votes")
}
